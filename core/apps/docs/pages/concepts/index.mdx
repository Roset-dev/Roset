---
title: Core Concepts
description: Understanding Roset's data model
---

# Core Concepts

Roset provides **filesystem semantics** on top of object storage. If you're familiar with S3, Google Cloud Storage, Azure Blob Storage, or any object storage system, this page will help you understand how Roset's concepts map to what you already know.

---

## Coming from Object Storage?

Roset wraps your object storage (S3, GCS, Azure Blob, R2, MinIO, etc.) with filesystem operations. Here's how the concepts map:

| Object Storage Concept   | Roset Equivalent  | What's Different                                                               |
| ------------------------ | ----------------- | ------------------------------------------------------------------------------ |
| **Bucket/Container**     | **Mount**         | A mount connects a bucket to Roset. You can have multiple mounts per tenant.   |
| **Object Key/Blob Name** | **Node** (file)   | Nodes have UUIDs, hierarchy, ACLs, and versions. They're not just strings.     |
| **Prefix/Path**          | **Node** (folder) | Folders are real entities. **Manifest caching** enables zero-latency listings. |
| **PUT/Upload**           | **Upload**        | Atomic, staged uploads with commit/abort. Supports versions.                   |
| **GET/Download**         | **Download**      | Permission-checked signed URLs. Works through shares too.                      |
| **Copy/Delete**          | **Move/Rename**   | O(1) metadata operations, not object copies.                                   |
| **List (prefix)**        | **List Children** | Hierarchical listing with permissions, not flat prefix scans.                  |

### Why the Abstraction?

1. **Atomic Operations** - Move files instantly without copying bytes
2. **Real Hierarchy** - Folders have IDs, permissions, and can be moved
3. **Access Control** - Inherited permissions, not just bucket policies
4. **Versioning** - Track file history without enabling bucket versioning
5. **POSIX-like** - Works with FUSE mounts, feels like a real filesystem
6. **Universal** - Same API whether you use S3, GCS, Azure, or others

Now let's dive into how these concepts work:

---

## Tenants

A **tenant** is the top-level isolation boundary. Each tenant has:

- Its own namespace (nodes, folders, files)
- Separate mounts (storage backends)
- Isolated permissions and API keys

Think of a tenant as a completely separate filesystem, even if multiple tenants use the same underlying S3 bucket.

---

## Mounts

A **mount** connects a tenant to a storage backend (S3/R2/MinIO):

<CodeBlock
  language="typescript"
  code={`Mount = {
  provider: "s3" | "minio" | "r2",
  bucket: "my-bucket",
  region: "us-east-1",
  basePrefix: "optional/prefix",
};`}
/>

Each tenant can have multiple mounts. One is marked as `default`.

## Nodes

Everything in Roset is a **node** : either a file or a folder.

<CodeBlock
  language="typescript"
  code={`Node = {
  id: "uuid",
  name: "report.pdf",
  type: "file" | "folder",
  parentId: "parent-uuid" | null,
  tenantId: "tenant-uuid",
  mountId: "mount-uuid",
};`}
/>

### Key Properties

- **ID is stable** — Nodes are identified by UUID, not path
- **Path is materialized** — Fast O(1) resolution and descendant queries
- **Efficient Operations** — Renames are lightweight; folder moves update only the subtree

## File Versions

Files can have multiple versions:

<CodeBlock
  language="typescript"
  code={`FileVersion = {
  nodeId: "file-uuid",
  storageKey: "tenant/file/1234567890",
  etag: "abc123",
  size: 1024000,
  isCurrent: true,
};`}
/>

Only one version is `current` at a time.

## ACLs (Access Control Lists)

Permissions are granted via ACLs with inheritance:

<CodeBlock
  language="typescript"
  code={`ACL = {
  nodeId: "folder-uuid",
  principalId: "user-123",
  permission: "read" | "write" | "admin",
  inheritMode: "inherit" | "override",
};`}
/>

### Inheritance Rules

1. Child nodes inherit parent permissions by default
2. Explicit ACLs on children can override
3. Permission checks walk up the tree

## Shares

Share links provide token-based access:

<CodeBlock
  language="typescript"
  code={`Share = {
  nodeId: "file-uuid",
  token: "abc123...",
  scope: "read" | "write",
  expiresAt: "2025-01-01T00:00:00Z",
  password: "hashed"(optional),
  maxDownloads: 10(optional),
};`}
/>

Shares work independently of user ACLs.

## Operations (Audit Log)

Every mutation is recorded:

<CodeBlock
  language="typescript"
  code={`Op = {
  tenantId: "...",
  actorId: "user-123",
  action: "node.created" | "upload.completed" | ...,
  targetNodeId: "...",
  payload: { ... }
}`}
/>

The ops table is append-only for compliance.
